<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on Lowtroo的垃圾桶</title><link>https://lowtroo.github.io/posts/</link><description>Recent content in Posts on Lowtroo的垃圾桶</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Fri, 09 Aug 2024 16:05:32 +0800</lastBuildDate><atom:link href="https://lowtroo.github.io/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>Concepts about Operating System</title><link>https://lowtroo.github.io/posts/operating_system/</link><pubDate>Fri, 09 Aug 2024 16:05:32 +0800</pubDate><guid>https://lowtroo.github.io/posts/operating_system/</guid><description>Four Fundamental OS concepts Threads: Execution Context Fully describes program state Program Counter, Registers, Execution Flags, Stack Address space Set of memory addresses accessible to program (for read or write) May be distinct from memory space of the physical machine (in which case programs operate in a virtual address space) Process: an instance of a running program Protected Address Space + One or more Threads Dual mode operation / Protection Only the “system” has the ability to access certain resources Combined with translation, isolates programs from each other and the OS from programs Thread of Control Thread: single unique execution context Program Counter, Registers, Execution Flags, Stack, Memory State A thread is executing on a processor (core) when it is resident in the processor registers Resident means: Registers hold the root state (context) of the thread: Including program counter (PC) register &amp;amp; currently executing instruction PC points at next instruction in memory Instructions stored in memory Including intermediate values for ongoing computations Can include actual values (like integers) or pointers to values in memory Stack pointer holds the address of the top of stack (which is in memory) The rest is “in memory” A thread is suspended (not executing) when its state is not loaded (resident) into the processor Processor state pointing at some other thread Program counter register is not pointing at next instruction from this thread Often: a copy of the last value for each register stored in memory Assume a single processor.</description></item><item><title>Something related to .Net</title><link>https://lowtroo.github.io/posts/something_related_to_dotnet/</link><pubDate>Sat, 20 Jan 2024 00:00:00 +0000</pubDate><guid>https://lowtroo.github.io/posts/something_related_to_dotnet/</guid><description>.Net Framework It&amp;rsquo;s Microsoft .Net Framework, which is a proprietary and original implementation of .Net. It can only run applications on Windows. .Net Framework is based on Common Language Runtime(CLR) and Base Class Libraries(BCL) and Common Intermediate Language(CIL).
.Net Core .Net Core is also an implementation of .Net. However, it can run on multiple platforms, and it&amp;rsquo;s open-sourced maintained by Microsoft and community with code hosted on Github. It supports some modern application framework such as ML.</description></item><item><title>关于Quake3中平方根倒数的计算方法</title><link>https://lowtroo.github.io/posts/fast_sqrt/</link><pubDate>Sun, 25 Sep 2022 00:00:00 +0000</pubDate><guid>https://lowtroo.github.io/posts/fast_sqrt/</guid><description>引 迭代算法介绍 初始的问题是：对于在区间 \(\left[ a, b \right]\) 上连续且单调的函数 \(f(x)\) ，求方程 \(f(x)=0\) 的近似解.
算法描述： 任意取一个定义域内的值\(x_0\)，开始迭代。 假设当前的近似解为\(x_i\)，则在点\((x_i,f(x_i))\) 上作\(f(x_i)\) 的切线\(l\)，其与 \(x\) 轴的交点记为 \(x_{i+1}\) ，那么这是一个更优的近似解。 切线的代数意义即为函数 \(f(x)\) 的导数，则可以得到这样的迭代式：
\begin{equation} x_{i+1}=x_{i}-\frac{f(x_i)}{f^{&amp;rsquo;}(x_i)} \end{equation}
关于其收敛性的证明，请参考[[http://staff.science.uva.nl/c.dominik/]][这里]
计算平方根 尝试求解 \(\sqrt[2]{x}\) 的值，其实等价于如下描述：
设 \(f(x)=x^2-n\) ，求 \(f(x)=0\) 的近似解。
按照前文的迭代式，可以得到：
\begin{equation} x_{i+1}=x_{i}-\frac{x_{i}^{2}-n}{2x_i} \end{equation}
设定一个合适的精度，经过有限次迭代最终能得到一个近似解
关于Quake3 背景 在Quake3代码中，有这样一段求解平方根倒数的代码：
float invSqrt(float x) { float xhalf = 0.5 * x; int i = *(int*)&amp;amp;x; // get bits for floating value i = 0x5f3759df - (i &amp;gt;&amp;gt; 1); // gives initial guess x = *(float*)&amp;amp;i; // convert bits back to float x = x * (1.</description></item></channel></rss>