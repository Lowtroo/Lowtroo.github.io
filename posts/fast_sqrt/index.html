<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>关于Quake3中平方根倒数的计算方法 | Lowtroo的垃圾桶</title>
<meta name=keywords content><meta name=description content="引 迭代算法介绍 初始的问题是：对于在区间 \(\left[ a, b \right]\) 上连续且单调的函数 \(f(x)\) ，求方程 \(f(x)=0\) 的近似解.
算法描述： 任意取一个定义域内的值\(x_0\)，开始迭代。 假设当前的近似解为\(x_i\)，则在点\((x_i,f(x_i))\) 上作\(f(x_i)\) 的切线\(l\)，其与 \(x\) 轴的交点记为 \(x_{i+1}\) ，那么这是一个更优的近似解。 切线的代数意义即为函数 \(f(x)\) 的导数，则可以得到这样的迭代式：
\begin{equation} x_{i+1}=x_{i}-\frac{f(x_i)}{f^{&rsquo;}(x_i)} \end{equation}
关于其收敛性的证明，请参考[[http://staff.science.uva.nl/c.dominik/]][这里]
计算平方根 尝试求解 \(\sqrt[2]{x}\) 的值，其实等价于如下描述：
设 \(f(x)=x^2-n\) ，求 \(f(x)=0\) 的近似解。
按照前文的迭代式，可以得到：
\begin{equation} x_{i+1}=x_{i}-\frac{x_{i}^{2}-n}{2x_i} \end{equation}
设定一个合适的精度，经过有限次迭代最终能得到一个近似解
关于Quake3 背景 在Quake3代码中，有这样一段求解平方根倒数的代码：
float invSqrt(float x) { float xhalf = 0.5 * x; int i = *(int*)&amp;x; // get bits for floating value i = 0x5f3759df - (i >> 1); // gives initial guess x = *(float*)&amp;i; // convert bits back to float x = x * (1."><meta name=author content><link rel=canonical href=https://lowtroo.github.io/posts/fast_sqrt/><link crossorigin=anonymous href=/assets/css/stylesheet.b609c58d5c11bb90b1a54e04005d74ad1ddf22165eb79f5533967e57df9c3b50.css integrity="sha256-tgnFjVwRu5CxpU4EAF10rR3fIhZet59VM5Z+V9+cO1A=" rel="preload stylesheet" as=style><link rel=icon href=https://lowtroo.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://lowtroo.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://lowtroo.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://lowtroo.github.io/apple-touch-icon.png><link rel=mask-icon href=https://lowtroo.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://lowtroo.github.io/posts/fast_sqrt/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script src=https://lowtroo.github.io/js/mathjax-config.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js></script><meta property="og:title" content="关于Quake3中平方根倒数的计算方法"><meta property="og:description" content="引 迭代算法介绍 初始的问题是：对于在区间 \(\left[ a, b \right]\) 上连续且单调的函数 \(f(x)\) ，求方程 \(f(x)=0\) 的近似解.
算法描述： 任意取一个定义域内的值\(x_0\)，开始迭代。 假设当前的近似解为\(x_i\)，则在点\((x_i,f(x_i))\) 上作\(f(x_i)\) 的切线\(l\)，其与 \(x\) 轴的交点记为 \(x_{i+1}\) ，那么这是一个更优的近似解。 切线的代数意义即为函数 \(f(x)\) 的导数，则可以得到这样的迭代式：
\begin{equation} x_{i+1}=x_{i}-\frac{f(x_i)}{f^{&rsquo;}(x_i)} \end{equation}
关于其收敛性的证明，请参考[[http://staff.science.uva.nl/c.dominik/]][这里]
计算平方根 尝试求解 \(\sqrt[2]{x}\) 的值，其实等价于如下描述：
设 \(f(x)=x^2-n\) ，求 \(f(x)=0\) 的近似解。
按照前文的迭代式，可以得到：
\begin{equation} x_{i+1}=x_{i}-\frac{x_{i}^{2}-n}{2x_i} \end{equation}
设定一个合适的精度，经过有限次迭代最终能得到一个近似解
关于Quake3 背景 在Quake3代码中，有这样一段求解平方根倒数的代码：
float invSqrt(float x) { float xhalf = 0.5 * x; int i = *(int*)&amp;x; // get bits for floating value i = 0x5f3759df - (i >> 1); // gives initial guess x = *(float*)&amp;i; // convert bits back to float x = x * (1."><meta property="og:type" content="article"><meta property="og:url" content="https://lowtroo.github.io/posts/fast_sqrt/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-09-25T00:00:00+00:00"><meta property="article:modified_time" content="2022-09-25T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="关于Quake3中平方根倒数的计算方法"><meta name=twitter:description content="引 迭代算法介绍 初始的问题是：对于在区间 \(\left[ a, b \right]\) 上连续且单调的函数 \(f(x)\) ，求方程 \(f(x)=0\) 的近似解.
算法描述： 任意取一个定义域内的值\(x_0\)，开始迭代。 假设当前的近似解为\(x_i\)，则在点\((x_i,f(x_i))\) 上作\(f(x_i)\) 的切线\(l\)，其与 \(x\) 轴的交点记为 \(x_{i+1}\) ，那么这是一个更优的近似解。 切线的代数意义即为函数 \(f(x)\) 的导数，则可以得到这样的迭代式：
\begin{equation} x_{i+1}=x_{i}-\frac{f(x_i)}{f^{&rsquo;}(x_i)} \end{equation}
关于其收敛性的证明，请参考[[http://staff.science.uva.nl/c.dominik/]][这里]
计算平方根 尝试求解 \(\sqrt[2]{x}\) 的值，其实等价于如下描述：
设 \(f(x)=x^2-n\) ，求 \(f(x)=0\) 的近似解。
按照前文的迭代式，可以得到：
\begin{equation} x_{i+1}=x_{i}-\frac{x_{i}^{2}-n}{2x_i} \end{equation}
设定一个合适的精度，经过有限次迭代最终能得到一个近似解
关于Quake3 背景 在Quake3代码中，有这样一段求解平方根倒数的代码：
float invSqrt(float x) { float xhalf = 0.5 * x; int i = *(int*)&amp;x; // get bits for floating value i = 0x5f3759df - (i >> 1); // gives initial guess x = *(float*)&amp;i; // convert bits back to float x = x * (1."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://lowtroo.github.io/posts/"},{"@type":"ListItem","position":2,"name":"关于Quake3中平方根倒数的计算方法","item":"https://lowtroo.github.io/posts/fast_sqrt/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"关于Quake3中平方根倒数的计算方法","name":"关于Quake3中平方根倒数的计算方法","description":"引 迭代算法介绍 初始的问题是：对于在区间 \\(\\left[ a, b \\right]\\) 上连续且单调的函数 \\(f(x)\\) ，求方程 \\(f(x)=0\\) 的近似解.\n算法描述： 任意取一个定义域内的值\\(x_0\\)，开始迭代。 假设当前的近似解为\\(x_i\\)，则在点\\((x_i,f(x_i))\\) 上作\\(f(x_i)\\) 的切线\\(l\\)，其与 \\(x\\) 轴的交点记为 \\(x_{i+1}\\) ，那么这是一个更优的近似解。 切线的代数意义即为函数 \\(f(x)\\) 的导数，则可以得到这样的迭代式：\n\\begin{equation} x_{i+1}=x_{i}-\\frac{f(x_i)}{f^{\u0026rsquo;}(x_i)} \\end{equation}\n关于其收敛性的证明，请参考[[http://staff.science.uva.nl/c.dominik/]][这里]\n计算平方根 尝试求解 \\(\\sqrt[2]{x}\\) 的值，其实等价于如下描述：\n设 \\(f(x)=x^2-n\\) ，求 \\(f(x)=0\\) 的近似解。\n按照前文的迭代式，可以得到：\n\\begin{equation} x_{i+1}=x_{i}-\\frac{x_{i}^{2}-n}{2x_i} \\end{equation}\n设定一个合适的精度，经过有限次迭代最终能得到一个近似解\n关于Quake3 背景 在Quake3代码中，有这样一段求解平方根倒数的代码：\nfloat invSqrt(float x) { float xhalf = 0.5 * x; int i = *(int*)\u0026amp;x; // get bits for floating value i = 0x5f3759df - (i \u0026gt;\u0026gt; 1); // gives initial guess x = *(float*)\u0026amp;i; // convert bits back to float x = x * (1.","keywords":[],"articleBody":"引 迭代算法介绍 初始的问题是：对于在区间 \\(\\left[ a, b \\right]\\) 上连续且单调的函数 \\(f(x)\\) ，求方程 \\(f(x)=0\\) 的近似解.\n算法描述： 任意取一个定义域内的值\\(x_0\\)，开始迭代。 假设当前的近似解为\\(x_i\\)，则在点\\((x_i,f(x_i))\\) 上作\\(f(x_i)\\) 的切线\\(l\\)，其与 \\(x\\) 轴的交点记为 \\(x_{i+1}\\) ，那么这是一个更优的近似解。 切线的代数意义即为函数 \\(f(x)\\) 的导数，则可以得到这样的迭代式：\n\\begin{equation} x_{i+1}=x_{i}-\\frac{f(x_i)}{f^{’}(x_i)} \\end{equation}\n关于其收敛性的证明，请参考[[http://staff.science.uva.nl/c.dominik/]][这里]\n计算平方根 尝试求解 \\(\\sqrt[2]{x}\\) 的值，其实等价于如下描述：\n设 \\(f(x)=x^2-n\\) ，求 \\(f(x)=0\\) 的近似解。\n按照前文的迭代式，可以得到：\n\\begin{equation} x_{i+1}=x_{i}-\\frac{x_{i}^{2}-n}{2x_i} \\end{equation}\n设定一个合适的精度，经过有限次迭代最终能得到一个近似解\n关于Quake3 背景 在Quake3代码中，有这样一段求解平方根倒数的代码：\nfloat invSqrt(float x) { float xhalf = 0.5 * x; int i = *(int*)\u0026x; // get bits for floating value i = 0x5f3759df - (i \u003e\u003e 1); // gives initial guess x = *(float*)\u0026i; // convert bits back to float x = x * (1.5 - xhalf * x * x); // Newton step return x; } 粗看这个代码的逻辑，其实很简单，先取了一个初始值，然后进行了一次迭代。\n关键在于，仅仅经过一次迭代，如何保证结果的精度达到要求？ 原因在于初始值的选取，本来就已经十分接近解，再进行一次迭代来消除估值本身的误差。\n合理性说明 先看这一段代码：\nint i = *(int*)\u0026x; // get bits for floating value i = 0x5f3759df - (i \u003e\u003e 1); // gives initial guess x = *(float*)\u0026i; // convert bits back to float 先将float转换为整型i，然后对i进行一次移位和减法，再将i转换为float。因此我们先考察浮点数在计算机中的表示。\n现代计算机的浮点数表示，一般遵循IEEE 754标准：其核心是采用以2为底数的科学计数法；\n在10进制下，科学计数法这样表示1043: \\(\\pm1.043\\times10^3\\) ，而在二进制下，也可以用同样的形式来表示一个浮点数。\n比如二进制写法的 \\(110.010\\) ，可以记为 \\(1.10010\\times2^2\\) 。\n要将这样的写法映射到内存中，考察32bit的float。\n最高位d31:符号位，0表示非负，1表示非正。（不直接说正负的原因是:存在 \\(\\pm 0\\) 的情况）。记为S\nd30-d23:指数域(exponent)，共8位，将其视为无符号整数，则其表示范围为 \\(0 \\thicksim 255\\) 。 因此如果用E来表示科学计数法中的指数，那么实际映射到这8位的数为127+E。此外，0和255有特殊值含义，但不影响下面的讨论。\nd22-d0:有效数字域(fraction)，共23位。在标准中规定，整数部分总是1,这样可以避免不必要的精度浪费，因此这23位全部用于表示剩余的小数部分。 这部分记为F。\n至此，除去0和特殊值，一个一般的浮点数，我们可以这样表示： \\((-1)^S\\times(1+F)\\times2^E\\) 。回到我们要考虑的问题，输入为整数的开方计算才有意义， 因此S位总是0,简化为 \\((1+F)\\times2^E\\) 。\n现在我们要求上面这个数的平方根的倒数也就是求\\(\\frac{1}{\\sqrt[2]{(1+F)\\times2^E}}\\)，我们想要求得的结果也可以用浮点数的计数法，即有效数字在 \\([1,2)\\) ， 指数域在 \\([-128,127]\\) 。\n分情况讨论：\nE为奇数 \\[ \\frac{1}{\\sqrt[2]{(1+F)\\times2^E}}=\\frac{1}{(1+F)^{\\frac{1}{2}}\\times2^{\\frac{E}{2}}}=(1+F)^{-\\frac{1}{2}}\\times2^{-\\frac{E}{2}}= (1+F)^{-\\frac{1}{2}}\\times2^{-(\\frac{E+1}{2}-\\frac{1}{2})}=\\sqrt[2]{\\frac{2}{1+F}}\\times2^{-\\frac{E+1}{2}} \\]\nE为偶数 \\[ \\frac{1}{\\sqrt[2]{(1+F)\\times2^E}}=\\frac{1}{(1+F)^{\\frac{1}{2}}\\times2^{\\frac{E}{2}}}=\\frac{2}{\\sqrt[2]{1+F}}\\times2^{-\\frac{E}{2}-1} \\] 无论E的奇偶性如何，这里都写成了浮点数的计数法的形式。(注意小数部分一定是1.xxx的形式)\n观察指数部分，可以发现：被开方数 \\(f\\) 的指数域，和 \\(f\\) 的平方根的倒数 \\(f^{’}\\) 的指数域，几乎是一半的差距， 因此考虑直接对 \\(f\\) 的指数域进行一次线性变换（移位并加上一个偏移量）， 来构造出 \\(f^{’}\\) 的指数域。\n\\(f\\) 的指数域： \\(127+E\\)\n\\(f^{’}\\) 的指数域： \\(127-\\frac{E+1}{2}\\) 或 \\(127-\\frac{E}{2}-1\\)\n假设偏移量为 \\(x\\)\nE为奇数时： \\[ x-\\frac{127+E}{2} = 127 - \\frac{E+1}{2} \\] 解得 \\[ x=190 \\] 也就是说，190-原来的指数域/2,恰好是平方根倒数的指数域\nE为偶数时： \\[ x-\\frac{127+E}{2} = 127 - \\frac{E}{2} - 1 \\] 解得\\[x=189\\]\n当E为偶数时，注意到指数域为奇数，即最后一位是1,经过右移后，减数的d22位为1,因此只要被减数的d22位为0,并且指数域为190, 那么fraction域作减法的时候，就会因为借位，使得指数域减1恰好变成189.\n至此，我们已经可以构造出一个数：其指数域为190,并且它的d22位为0 我们回到代码中的magic number,其值为0x5f3759df，其二进制表示为 0 10111110 01101110101100111011111,发现满足上述条件。\n再次注意到，当E为偶数时，做完减法以后，指数域的结果一定是 \\(127 - \\frac{E}{2} - 1\\) ，但E为奇数时，由于被减数和减数的d22位都为0,如果被减数的d21-d0 比减数小，就会向高位借位，使得指数域相减的结果小1,这里会导致一定误差，但会被后续的迭代缩小。\n接下来尝试构造剩余的位(d21-d0)。\n假设将magic number看作是一个浮点数，其小数部分为M，由于其d22位为0,则 \\(0 \\le M \u003c 0.5\\) ，因此在作 \\(magic - (i » 1)\\) 时，可以看作是定点小数的减法。 分情况讨论：\nE为奇数 此时指数域为偶数，即最后一位是0,经过右移后，d22位为0，因此小数部分的值为 \\(\\frac{F}{2}\\) ， 最后一位如果是1,经过右移后会被舍弃掉，这个因为太小对误差影响不大。\n假设 \\(M \\ge \\frac{F}{2}\\) ，那就不需要向指数域借位，计算结果为：小数部分 \\(M - \\frac{F}{2}\\) ，且指数域部分符合预期， 相对误差为 \\(\\Bigg|1-\\frac{1+M-\\frac{F}{2}}{\\sqrt[2]{\\frac{2}{1+F}}} \\Bigg|\\) ，（注意前文对奇数的情况的分析）；\n假设\\(M \u003c \\frac{F}{2}\\)，此时需要向指数域借位，计算结果为：小数部分 \\(1+M-\\frac{F}{2}\\) ，指数域比预期小1， 因此在相对误差中需要补上这个差值： \\(\\Bigg|1-\\frac{\\frac{2+M-\\frac{F}{2}}{2}}{\\sqrt[2]{\\frac{2}{1+F}}}\\Bigg|\\) .\nE为偶数 此时指数域为奇数，即最后一位为1,经过右移后，d22位为1,因此小数部分的值为 \\(\\frac{1}{2}+\\frac{F}{2}\\) ， 前面说了，这种情况一定会产生借位，但指数域是符合预期的， 因此相对误差为： \\(\\Bigg|1-\\frac{2+M-\\frac{1}{2}-\\frac{F}{2}}{\\frac{2}{\\sqrt[2]{1+F}}}\\Bigg|\\) 。\n到这一步，我们可以构造一个函数 \\(g(M)\\) ，它是从M到该M取值下的最大误差值（从前面的三个误差中求得的最大值）的映射。于是我们只要对这个 \\(g(M)\\) 作分析， 找到一个M使得 \\(g(M)\\) 的值最小，我们就得到了一个最优的magic number。\n理论上说，这个区间的数是有限个的，通过穷举肯定能找到那个最优的解。但是计算量有点大。\n因此我们考虑这样：在magic number的取值范围内 \\([0x5f000000,0x5f3fffff]\\) ，均匀地取一些数，然后遍历常用浮点数计算 \\(g(M)\\) ，发现其曲线在区间内为一个波谷。\n因此大胆假设其在区间内符合先递减后递增的连续函数。\n定义start，end，初始为0x5F000000和0x5F3FFFFF，将区间[start, end]均匀分成32段，求33个数中g(M)最小的值，然后再将start和end定义为它的前一个和后一个。 反复迭代，直至区间收敛到一个比较小的范围，再对这个小区间进行穷举，最后求得一个最优解。\n2003年普度大学数学家Chris Lomont找到了最优解0x5f375a86。至此，所有关于这个magic number的秘密就“逆向”到这里。\n其内在的数学本质 如果要用一句话概括其本质，那么就是：浮点数的二进制表示近似于对数运算，只是带了一些偏移。\n\\begin{equation} y=\\frac{1}{\\sqrt[2]{x}}=x^{-\\frac{1}{2}} \\Rightarrow \\log_2 (y) = -\\frac{1}{2}\\log_2(x) \\end{equation}\n将y，x作为浮点数，带入到上面的式子中，得到\n\\begin{equation} \\log_2((1+\\frac{F_y}{2^{23}}) \\times 2^{E_y-127}) = -\\frac{1}{2} \\times \\log_2((1+\\frac{F_x}{2^{23}}) \\times 2^{E_x-127}) \\Rightarrow E_y - 127 + \\log_2(1+\\frac{F_y}{2^{23}}) =-\\frac{1}{2} \\times (E_x - 127 + \\log_2(1+\\frac{F_x}{2^{23}})) \\end{equation}\n学过高数的你一定知道近似公式\\[ \\log_2(1+x) = x + \\epsilon\\] 因此带入得到：\n\\begin{equation} E_y -127 + \\frac{F_y}{2^{23}} + \\epsilon =-\\frac{1}{2}(E_x-127) - \\frac{1}{2}(\\frac{F_x}{2^{23}}+\\epsilon) \\Rightarrow E_y \\times 2^{23} + F_y = \\frac{3}{2}(127-\\epsilon)2^{23} - \\frac{1}{2}(E_x\\times2^{23}+F_x) \\end{equation}\n即左边为y的整数表达，右边为y的整数表达右移后，用一个数减，这个数如果忽略 \\(\\epsilon\\) ，则刚好是一个指数域为190的数。\n因此，剩余的工作就是找到一个合适 \\(\\epsilon\\) 的值（其实就是上一节对小数部分的分析，在本质上的体现），使得这部分估计的偏差最小即可。\n然后再进行一次或者两次牛顿迭代，抹除掉估计的偏差即可。\nIn Addition 现在有了快速计算平方根倒数的方法，用这个的结果乘以x本身，就得到了x的平方根。\n","wordCount":"393","inLanguage":"en","datePublished":"2022-09-25T00:00:00Z","dateModified":"2022-09-25T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://lowtroo.github.io/posts/fast_sqrt/"},"publisher":{"@type":"Organization","name":"Lowtroo的垃圾桶","logo":{"@type":"ImageObject","url":"https://lowtroo.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://lowtroo.github.io/ accesskey=h title="Lowtroo的垃圾桶 (Alt + H)">Lowtroo的垃圾桶</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li></ul></div></div><ul id=menu></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">关于Quake3中平方根倒数的计算方法</h1><div class=post-meta><span title='2022-09-25 00:00:00 +0000 UTC'>2022-09-25</span></div></header><div class=post-content><h2 id=引>引<a hidden class=anchor aria-hidden=true href=#引>#</a></h2><h3 id=迭代算法介绍>迭代算法介绍<a hidden class=anchor aria-hidden=true href=#迭代算法介绍>#</a></h3><p>初始的问题是：对于在区间 \(\left[ a, b \right]\) 上连续且单调的函数 \(f(x)\) ，求方程 \(f(x)=0\) 的近似解.</p><p>算法描述：
任意取一个定义域内的值\(x_0\)，开始迭代。
假设当前的近似解为\(x_i\)，则在点\((x_i,f(x_i))\) 上作\(f(x_i)\) 的切线\(l\)，其与 \(x\) 轴的交点记为 \(x_{i+1}\) ，那么这是一个更优的近似解。
切线的代数意义即为函数 \(f(x)\) 的导数，则可以得到这样的迭代式：</p><p>\begin{equation}
x_{i+1}=x_{i}-\frac{f(x_i)}{f^{&rsquo;}(x_i)}
\end{equation}</p><p>关于其收敛性的证明，请参考[[<a href=http://staff.science.uva.nl/c.dominik/>http://staff.science.uva.nl/c.dominik/</a>]][这里]</p><h3 id=计算平方根>计算平方根<a hidden class=anchor aria-hidden=true href=#计算平方根>#</a></h3><p>尝试求解 \(\sqrt[2]{x}\) 的值，其实等价于如下描述：</p><p>设 \(f(x)=x^2-n\) ，求 \(f(x)=0\) 的近似解。</p><p>按照前文的迭代式，可以得到：</p><p>\begin{equation}
x_{i+1}=x_{i}-\frac{x_{i}^{2}-n}{2x_i}
\end{equation}</p><p>设定一个合适的精度，经过有限次迭代最终能得到一个近似解</p><h2 id=关于quake3>关于Quake3<a hidden class=anchor aria-hidden=true href=#关于quake3>#</a></h2><h3 id=背景>背景<a hidden class=anchor aria-hidden=true href=#背景>#</a></h3><p>在Quake3代码中，有这样一段求解平方根倒数的代码：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C><span style=display:flex><span><span style=color:#66d9ef>float</span> <span style=color:#a6e22e>invSqrt</span>(<span style=color:#66d9ef>float</span> x)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float</span> xhalf <span style=color:#f92672>=</span> <span style=color:#ae81ff>0.5</span> <span style=color:#f92672>*</span> x;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#f92672>*</span>(<span style=color:#66d9ef>int</span><span style=color:#f92672>*</span>)<span style=color:#f92672>&amp;</span>x; <span style=color:#75715e>// get bits for floating value
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0x5f3759df</span> <span style=color:#f92672>-</span> (i <span style=color:#f92672>&gt;&gt;</span> <span style=color:#ae81ff>1</span>); <span style=color:#75715e>// gives initial guess
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        x <span style=color:#f92672>=</span> <span style=color:#f92672>*</span>(<span style=color:#66d9ef>float</span><span style=color:#f92672>*</span>)<span style=color:#f92672>&amp;</span>i; <span style=color:#75715e>// convert bits back to float
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        x <span style=color:#f92672>=</span> x <span style=color:#f92672>*</span> (<span style=color:#ae81ff>1.5</span> <span style=color:#f92672>-</span> xhalf <span style=color:#f92672>*</span> x <span style=color:#f92672>*</span> x); <span style=color:#75715e>// Newton step
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>return</span> x;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>粗看这个代码的逻辑，其实很简单，先取了一个初始值，然后进行了一次迭代。</p><p>关键在于，仅仅经过一次迭代，如何保证结果的精度达到要求？
原因在于初始值的选取，本来就已经十分接近解，再进行一次迭代来消除估值本身的误差。</p><h3 id=合理性说明>合理性说明<a hidden class=anchor aria-hidden=true href=#合理性说明>#</a></h3><p>先看这一段代码：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C><span style=display:flex><span><span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#f92672>*</span>(<span style=color:#66d9ef>int</span><span style=color:#f92672>*</span>)<span style=color:#f92672>&amp;</span>x; <span style=color:#75715e>// get bits for floating value
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0x5f3759df</span> <span style=color:#f92672>-</span> (i <span style=color:#f92672>&gt;&gt;</span> <span style=color:#ae81ff>1</span>); <span style=color:#75715e>// gives initial guess
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>x <span style=color:#f92672>=</span> <span style=color:#f92672>*</span>(<span style=color:#66d9ef>float</span><span style=color:#f92672>*</span>)<span style=color:#f92672>&amp;</span>i; <span style=color:#75715e>// convert bits back to float
</span></span></span></code></pre></div><p>先将float转换为整型i，然后对i进行一次移位和减法，再将i转换为float。因此我们先考察浮点数在计算机中的表示。</p><p>现代计算机的浮点数表示，一般遵循IEEE 754标准：其核心是采用以2为底数的科学计数法；</p><p>在10进制下，科学计数法这样表示1043: \(\pm1.043\times10^3\) ，而在二进制下，也可以用同样的形式来表示一个浮点数。</p><p>比如二进制写法的 \(110.010\) ，可以记为 \(1.10010\times2^2\) 。</p><p>要将这样的写法映射到内存中，考察32bit的float。</p><p>最高位d31:符号位，0表示非负，1表示非正。（不直接说正负的原因是:存在 \(\pm 0\) 的情况）。记为S</p><p>d30-d23:指数域(exponent)，共8位，将其视为无符号整数，则其表示范围为 \(0 \thicksim 255\) 。
因此如果用E来表示科学计数法中的指数，那么实际映射到这8位的数为127+E。此外，0和255有特殊值含义，但不影响下面的讨论。</p><p>d22-d0:有效数字域(fraction)，共23位。在标准中规定，整数部分总是1,这样可以避免不必要的精度浪费，因此这23位全部用于表示剩余的小数部分。
这部分记为F。</p><p>至此，除去0和特殊值，一个一般的浮点数，我们可以这样表示： \((-1)^S\times(1+F)\times2^E\) 。回到我们要考虑的问题，输入为整数的开方计算才有意义，
因此S位总是0,简化为 \((1+F)\times2^E\) 。</p><p>现在我们要求上面这个数的平方根的倒数也就是求\(\frac{1}{\sqrt[2]{(1+F)\times2^E}}\)，我们想要求得的结果也可以用浮点数的计数法，即有效数字在 \([1,2)\) ，
指数域在 \([-128,127]\) 。</p><p>分情况讨论：</p><h4 id=e为奇数>E为奇数<a hidden class=anchor aria-hidden=true href=#e为奇数>#</a></h4><p>\[ \frac{1}{\sqrt[2]{(1+F)\times2^E}}=\frac{1}{(1+F)^{\frac{1}{2}}\times2^{\frac{E}{2}}}=(1+F)^{-\frac{1}{2}}\times2^{-\frac{E}{2}}=
(1+F)^{-\frac{1}{2}}\times2^{-(\frac{E+1}{2}-\frac{1}{2})}=\sqrt[2]{\frac{2}{1+F}}\times2^{-\frac{E+1}{2}}
\]</p><h4 id=e为偶数>E为偶数<a hidden class=anchor aria-hidden=true href=#e为偶数>#</a></h4><p>\[
\frac{1}{\sqrt[2]{(1+F)\times2^E}}=\frac{1}{(1+F)^{\frac{1}{2}}\times2^{\frac{E}{2}}}=\frac{2}{\sqrt[2]{1+F}}\times2^{-\frac{E}{2}-1}
\]
无论E的奇偶性如何，这里都写成了浮点数的计数法的形式。(注意小数部分一定是1.xxx的形式)</p><p>观察指数部分，可以发现：被开方数 \(f\) 的指数域，和 \(f\) 的平方根的倒数 \(f^{&rsquo;}\) 的指数域，几乎是一半的差距，
因此考虑直接对 \(f\) 的指数域进行一次线性变换（移位并加上一个偏移量），
来构造出 \(f^{&rsquo;}\) 的指数域。</p><p>\(f\) 的指数域： \(127+E\)</p><p>\(f^{&rsquo;}\) 的指数域： \(127-\frac{E+1}{2}\) 或 \(127-\frac{E}{2}-1\)</p><p>假设偏移量为 \(x\)</p><p>E为奇数时：
\[
x-\frac{127+E}{2} = 127 - \frac{E+1}{2}
\]
解得
\[
x=190
\]
也就是说，190-原来的指数域/2,恰好是平方根倒数的指数域</p><p>E为偶数时：
\[
x-\frac{127+E}{2} = 127 - \frac{E}{2} - 1
\]
解得\[x=189\]</p><p>当E为偶数时，注意到指数域为奇数，即最后一位是1,经过右移后，减数的d22位为1,因此只要被减数的d22位为0,并且指数域为190,
那么fraction域作减法的时候，就会因为借位，使得指数域减1恰好变成189.</p><p>至此，我们已经可以构造出一个数：其指数域为190,并且它的d22位为0
我们回到代码中的magic number,其值为0x5f3759df，其二进制表示为 0 10111110 01101110101100111011111,发现满足上述条件。</p><p>再次注意到，当E为偶数时，做完减法以后，指数域的结果一定是 \(127 - \frac{E}{2} - 1\) ，但E为奇数时，由于被减数和减数的d22位都为0,如果被减数的d21-d0
比减数小，就会向高位借位，使得指数域相减的结果小1,这里会导致一定误差，但会被后续的迭代缩小。</p><p>接下来尝试构造剩余的位(d21-d0)。</p><p>假设将magic number看作是一个浮点数，其小数部分为M，由于其d22位为0,则 \(0 \le M &lt; 0.5\) ，因此在作 \(magic - (i &#187; 1)\) 时，可以看作是定点小数的减法。
分情况讨论：</p><h4 id=e为奇数>E为奇数<a hidden class=anchor aria-hidden=true href=#e为奇数>#</a></h4><p>此时指数域为偶数，即最后一位是0,经过右移后，d22位为0，因此小数部分的值为 \(\frac{F}{2}\) ，
最后一位如果是1,经过右移后会被舍弃掉，这个因为太小对误差影响不大。</p><p>假设 \(M \ge \frac{F}{2}\) ，那就不需要向指数域借位，计算结果为：小数部分 \(M - \frac{F}{2}\) ，且指数域部分符合预期，
相对误差为 \(\Bigg|1-\frac{1+M-\frac{F}{2}}{\sqrt[2]{\frac{2}{1+F}}} \Bigg|\) ，（注意前文对奇数的情况的分析）；</p><p>假设\(M &lt; \frac{F}{2}\)，此时需要向指数域借位，计算结果为：小数部分 \(1+M-\frac{F}{2}\) ，指数域比预期小1，
因此在相对误差中需要补上这个差值： \(\Bigg|1-\frac{\frac{2+M-\frac{F}{2}}{2}}{\sqrt[2]{\frac{2}{1+F}}}\Bigg|\) .</p><h4 id=e为偶数>E为偶数<a hidden class=anchor aria-hidden=true href=#e为偶数>#</a></h4><p>此时指数域为奇数，即最后一位为1,经过右移后，d22位为1,因此小数部分的值为 \(\frac{1}{2}+\frac{F}{2}\) ，
前面说了，这种情况一定会产生借位，但指数域是符合预期的，
因此相对误差为： \(\Bigg|1-\frac{2+M-\frac{1}{2}-\frac{F}{2}}{\frac{2}{\sqrt[2]{1+F}}}\Bigg|\) 。</p><p>到这一步，我们可以构造一个函数 \(g(M)\) ，它是从M到该M取值下的最大误差值（从前面的三个误差中求得的最大值）的映射。于是我们只要对这个 \(g(M)\) 作分析，
找到一个M使得 \(g(M)\) 的值最小，我们就得到了一个最优的magic number。</p><p>理论上说，这个区间的数是有限个的，通过穷举肯定能找到那个最优的解。但是计算量有点大。</p><p>因此我们考虑这样：在magic number的取值范围内 \([0x5f000000,0x5f3fffff]\) ，均匀地取一些数，然后遍历常用浮点数计算 \(g(M)\) ，发现其曲线在区间内为一个波谷。</p><p>因此大胆假设其在区间内符合先递减后递增的连续函数。</p><p>定义start，end，初始为0x5F000000和0x5F3FFFFF，将区间[start, end]均匀分成32段，求33个数中g(M)最小的值，然后再将start和end定义为它的前一个和后一个。
反复迭代，直至区间收敛到一个比较小的范围，再对这个小区间进行穷举，最后求得一个最优解。</p><p>2003年普度大学数学家Chris Lomont找到了最优解0x5f375a86。至此，所有关于这个magic number的秘密就“逆向”到这里。</p><h3 id=其内在的数学本质>其内在的数学本质<a hidden class=anchor aria-hidden=true href=#其内在的数学本质>#</a></h3><p>如果要用一句话概括其本质，那么就是：浮点数的二进制表示近似于对数运算，只是带了一些偏移。</p><p>\begin{equation}
y=\frac{1}{\sqrt[2]{x}}=x^{-\frac{1}{2}}
\Rightarrow \log_2 (y) = -\frac{1}{2}\log_2(x)
\end{equation}</p><p>将y，x作为浮点数，带入到上面的式子中，得到</p><p>\begin{equation}
\log_2((1+\frac{F_y}{2^{23}}) \times 2^{E_y-127}) = -\frac{1}{2} \times \log_2((1+\frac{F_x}{2^{23}}) \times 2^{E_x-127})
\Rightarrow E_y - 127 + \log_2(1+\frac{F_y}{2^{23}}) =-\frac{1}{2} \times (E_x - 127 + \log_2(1+\frac{F_x}{2^{23}}))
\end{equation}</p><p>学过高数的你一定知道近似公式\[ \log_2(1+x) = x + \epsilon\]
因此带入得到：</p><p>\begin{equation}
E_y -127 + \frac{F_y}{2^{23}} + \epsilon =-\frac{1}{2}(E_x-127) - \frac{1}{2}(\frac{F_x}{2^{23}}+\epsilon)
\Rightarrow E_y \times 2^{23} + F_y = \frac{3}{2}(127-\epsilon)2^{23} - \frac{1}{2}(E_x\times2^{23}+F_x)
\end{equation}</p><p>即左边为y的整数表达，右边为y的整数表达右移后，用一个数减，这个数如果忽略 \(\epsilon\) ，则刚好是一个指数域为190的数。</p><p>因此，剩余的工作就是找到一个合适 \(\epsilon\) 的值（其实就是上一节对小数部分的分析，在本质上的体现），使得这部分估计的偏差最小即可。</p><p>然后再进行一次或者两次牛顿迭代，抹除掉估计的偏差即可。</p><h3 id=in-addition>In Addition<a hidden class=anchor aria-hidden=true href=#in-addition>#</a></h3><p>现在有了快速计算平方根倒数的方法，用这个的结果乘以x本身，就得到了x的平方根。</p></div><footer class=post-footer><ul class=post-tags></ul></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://lowtroo.github.io/>Lowtroo的垃圾桶</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>